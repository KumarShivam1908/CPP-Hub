# 144. Binary Tree Preorder Traversal
Solved
Easy
Topics
Companies
Given the root of a binary tree, return the preorder traversal of its nodes' values.

## Examples

### Example 1:
Input: root = [1,null,2,3]
Output: [1,2,3]

### Example 2:
Input: root = [1,2,3,4,5,null,8,null,null,6,7,9]
Output: [1,2,4,5,6,7,3,8,9]

### Example 3:
Input: root = []
Output: []

### Example 4:
Input: root = [1]
Output: [1]

## Constraints:
- The number of nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100

## Intuition
Preorder traversal is a depth-first traversal technique that follows a specific order:
1. Visit the current node (root)
2. Traverse the left subtree
3. Traverse the right subtree

This is commonly known as "Root-Left-Right" traversal. In preorder traversal, we process the current node before its children, making it useful for creating a copy of a tree or evaluating expressions represented by trees.

## Approach 1: Recursive Solution

### Explanation
Recursion naturally fits tree traversal problems since trees are inherently recursive data structures:
1. Process the current node's value first
2. Recursively apply preorder traversal to the left subtree
3. Recursively apply preorder traversal to the right subtree

### Code
```cpp
class Solution {
public:
    // Helper function to perform recursive preorder traversal
    void Helper(TreeNode* root, vector<int> & res){
        // Base case: if current node is null, return
        if (root == nullptr) {
            return;
        }
        
        // Step 1: Process current node (add value to result)
        res.push_back(root->val);
        
        // Step 2: Recursively traverse left subtree
        Helper(root->left, res);
        
        // Step 3: Recursively traverse right subtree
        Helper(root->right, res);
    }
    
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;  // Vector to store the result
        Helper(root, res);  // Call helper function starting from root
        return res;  // Return the final result
    }
};
```

### Complexity Analysis
- **Time Complexity: O(n)** where n is the number of nodes in the tree. Each node is visited exactly once.
- **Space Complexity: O(h)** where h is the height of the tree. This represents the maximum recursion stack depth. In the worst case (skewed tree), this can be O(n).

### Dry Run
Let's trace the algorithm with this example:
```
    1
   / \
  2   3
```

1. Start at root (1):
   - Add 1 to result: `res = [1]`
   - Recursively call Helper on left child (2)
     - Add 2 to result: `res = [1, 2]`
     - Recursively call Helper on left child of 2 (null) → return
     - Recursively call Helper on right child of 2 (null) → return
   - Recursively call Helper on right child (3)
     - Add 3 to result: `res = [1, 2, 3]`
     - Recursively call Helper on left child of 3 (null) → return
     - Recursively call Helper on right child of 3 (null) → return
2. Final result: `[1, 2, 3]`

## Approach 2: Iterative Solution

### Explanation
We can also implement preorder traversal iteratively using a stack:
1. Initialize a stack and start with the root node
2. While there are nodes to process:
   - If current node exists:
     - Process it (add value to result)
     - Push its right child to stack (to process later)
     - Move to left child        }
   - If current node is null:
     - Pop a node from stack and make it the current nodeeturn res;
    }
### Code
```cpp
class Solution {public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;  // Vector to store the result
        stack<TreeNode*> s;  // Stack to track nodes to visit
        
        TreeNode* curr = root;  // Start with the root node
        
        while(curr != nullptr || !s.empty()) {
            if(curr != nullptr) {
                // Step 1: Process current node
                res.push_back(curr->val);
                
                // Step 2: Push right child to stack (to be processed later)
                if(curr->right != nullptr) {
                    s.push(curr->right);
                }
                
                // Step 3: Move to left child
                curr = curr->left;
            } else {
                // No more left children, process node from stack
                curr = s.top();
                s.pop();
            }
        }
        
        return res;
    }
};
```

### Complexity Analysis
- **Time Complexity: O(n)** where n is the number of nodes in the tree.
- **Space Complexity: O(h)** where h is the height of the tree. In the worst case, the stack can contain O(n) nodes for a skewed tree.

### Dry Run
Let's trace the algorithm with the same example:
```
    1
   / \
  2   3
```

1. Initialize: `res = [], stack = [], curr = 1`
2. First iteration:
   - curr (1) is not null
   - Add 1 to result: `res = [1]`
   - Push right child (3) to stack: `stack = [3]`
   - Move to left child: `curr = 2`
3. Second iteration:
   - curr (2) is not null
   - Add 2 to result: `res = [1, 2]`
   - No right child to push
   - Move to left child: `curr = null`
4. Third iteration:
   - curr is null, pop from stack: `curr = 3, stack = []`
5. Fourth iteration:
   - curr (3) is not null
   - Add 3 to result: `res = [1, 2, 3]`
   - No right child to push
   - Move to left child: `curr = null`
6. Fifth iteration:
   - curr is null, stack is empty, exit loop
7. Final result: `[1, 2, 3]`